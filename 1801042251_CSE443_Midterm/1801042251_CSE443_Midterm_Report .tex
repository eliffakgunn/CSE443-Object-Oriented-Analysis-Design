%%%%%%%%%%%%%%%%% DO NOT CHANGE HERE %%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{
    \documentclass[twoside,11pt]{article}
    %%%%% PACKAGES %%%%%%
    \usepackage{pgm2016}
    \usepackage{amsmath}
    \usepackage{algorithm}
    \usepackage[noend]{algpseudocode}
    \usepackage{subcaption}
    \usepackage[english]{babel}	
    \usepackage{paralist}	
    \usepackage[lowtilde]{url}
    \usepackage{fixltx2e}
    \usepackage{listings}
    \usepackage{color}
    \usepackage{hyperref}
    
    \usepackage{auto-pst-pdf}
    \usepackage{pst-all}
    \usepackage{pstricks-add}
    
    %%%%% MACROS %%%%%%
    \algrenewcommand\Return{\State \algorithmicreturn{} }
    \algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}
    \renewcommand{\thesubfigure}{\roman{subfigure}}
    \definecolor{codegreen}{rgb}{0,0.6,0}
    \definecolor{codegray}{rgb}{0.5,0.5,0.5}
    \definecolor{codepurple}{rgb}{0.58,0,0.82}
    \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
    \lstdefinestyle{mystyle}{
       backgroundcolor=\color{backcolour},  
       commentstyle=\color{codegreen},
       keywordstyle=\color{magenta},
       numberstyle=\tiny\color{codegray},
       stringstyle=\color{codepurple},
       basicstyle=\footnotesize,
       breakatwhitespace=false,        
       breaklines=true,                
       captionpos=b,                    
       keepspaces=true,                
       numbers=left,                    
       numbersep=5pt,                  
       showspaces=false,                
       showstringspaces=false,
       showtabs=false,                  
       tabsize=2
    }
    \lstset{style=mystyle}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% }

%%%%%%%%%%%%%%%%%%%%%%%% CHANGE HERE %%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% {
\newcommand\course{CSE 443}
\newcommand\courseName{Object Oriented Analysis and Design}
\newcommand\semester{Spring 2020}
\newcommand\studentName{Elif Akg√ºn}                  % <-- YOUR NAME
\newcommand\studentNumber{1801042251}                % <-- STUDENT ID #
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%% DO NOT CHANGE HERE %%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%{

    \ShortHeadings{Gebze Technical University -  \course ~~ \courseName}{\studentName - \studentNumber}
    \firstpageno{1}
    
    \begin{document}
    
    \title{Midterm Project Report\assignmentNumber}
    
    \author{\name \studentName \email \studentEmail \\
    \studentNumber
    \addr
    }
    
    \maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% }

\section{Part 1} 
\label{sec:background}

\subsection{Design Explanation}

In this part, we have got the same product families (display, battery, CPU \& Ram, storage, camera and case) but different implementations. For example, Turkey uses one set of ingredients and EU another. All market's smartphones made from the same components, but each market has a different implementation of those components. We need to create ingredient families not ingredients so I used Abstract Factory design pattern. \newline

I created an interface for each component (Display, Battery etc.). Then I created concrete classes of those interfaces. For example, I created LithiumBoron, LithiumCobalt and LithiumIon classes that implement Battery interface. Also I created a factory to create our ingredients which is SmartphoneFactory; the factory is responsible for creating each ingredient in the ingredient family. For each ingredient I defined a create method in the interface. Then I created concrete factory classes for each market that implement SmartphoneFactory which are TurkeySmartphoneFactory, EUSmartphoneFactory, and GlobalSmartphoneFactory. These classes create own ingredients. I created an abstact class which is Smartphone. It holds a set of ingredients that are used in production. Also it has some methods to attach cpu & ram to the board, attach display, attach battery, attach storage, attach camera and enclose the phone case. There are three subclasses of Smartphone which are MaximumEffort, IflasDeluxe, and IIAmanIflas. They have a SmartphoneFactory object and a constructor with SmartphoneFactory paremeter. In constructor, it sets data field of classes with appropriate ingredients. Thanks to polymorphism it goes proper factory and creates proper ingredient at run time. Also there is another abstract class PhoneStore. It has two methods: orderSmartphone and an abstract method createSmartphone. orderSmartphone method has a string type parameter. First, it creates asked Smartphone object at run time. Then it produces smartphone step by step. Lastly, there are three classes that extends PhoneStore class: TurkeyStore, EUStore, and GlobalStore. They have only createSmartphone method and they create proper smartphone object according to parameter. For example if parameter(item) equals MaximumEffort, it creates MaximumEffort object. \newpage

\subsection{Class Diagram}

\begin{figure}[h]
\caption{Class Diagram of Part 1}
\centering
\includegraphics[width=1\textwidth]{figure/part1.png}
\end{figure}

\subsection{Tests}

\begin{figure}[h]
\caption{Main Method}
\centering
\includegraphics[width=0.9\textwidth]{figure/main1.png}
\end{figure}

\newpage

\begin{figure}[h]
\caption{Output_1}
\centering
\includegraphics[width=0.9\textwidth]{figure/output1_1.png}
\end{figure}

\begin{figure}[h]
\caption{Output_2}
\centering
\includegraphics[width=0.9\textwidth]{figure/output1_2.png}
\end{figure}

\begin{figure}[h]
\caption{Output_3}
\centering
\includegraphics[width=1\textwidth]{figure/output1_3.png}
\end{figure}

\newpage

\section{Part 2} 
\label{sec:background}

\subsection{Design Explanation}

In this part, there are two interfaces: ModernPayment and TurboPayment. TurboPayment is extensively an old binary library from the 1990s and we cannot modify this interface. Although ModernPayment has pay method, TurboPayment has payInTurbo where all the method parameters have the same meaning and role as in ModernPayment. We should be able to continue using all classes that implement the TurboPayment interface with the new ModernPayment interface. I used Adapter Pattern because it converts the interface of a class into another interface the clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.\newline

I created two interfaces: ModernPayment and TurboPayment. Also I created conctrete class of these interfaces which are ConcreteModernPayment and ConcreteTurboPayment. They implement pay and payInTurbo methods respectively. I created a adapter class ModernPaymentAdapter that implements TurboPayment interface. It has a ModernPayment object, a constructor with ModernPayment object parameter and also payInTurbo method. In payInTurbo method, it goes to ModernPayment's pay with modernPayment object.

\newpage
\subsection{Class Diagram}

\begin{figure}[h]
\caption{Class Diagram of Part 2}
\centering
\includegraphics[width=1\textwidth]{figure/part2.png}
\end{figure}

\subsection{Tests}

\begin{figure}[h]
\caption{Main Method}
\centering
\includegraphics[width=1\textwidth]{figure/main2.png}
\end{figure}

\newpage

\begin{figure}[h]
\caption{Output}
\centering
\includegraphics[width=1\textwidth]{figure/output2.png}
\end{figure}

\section{Part 3} 
\label{sec:background}

\subsection{Design Explanation}

In this part, there are some database operations. A database operation can be a SELECT, an UPDATE or an ALTER. A transaction is a series of operations (a SELECT followed by an ALTER, or an UPDATE followed by ALTER followed by SELECT, and so on). We need to execute and undo the operations. I used Command Pattern because should one of the operations fail, all others must be reversed or discarded. The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations. \newline

I created Command interface and it has two methods: execute and undo. Execute method executes operations and undo method takes back the operations. Then, I create an abstract class Operation and its subclasses Select, Update and Alter. It has doOperation and backOperation methods. doOperation method does proper operation and backOperation method takes back this operation. Also there are three concrete classes that implement Command interface: SelectCommand, UpdateCommand and AlterCommand. They has Select object, Update object and Alter object respectively. With this objects, they execute operations with proper doOperation method and undo operations with proper backOperation method. I created Invoker class. It has commands list and a stack to keep executed operations. setCommand method adds operation to list that comes as parameter, runOperation method executes operations that invoked, and rollback method discard all methods if one of the operations fail.\newline

In Invoker class, when executing the operations, if one of the operations fail it throws an exception. Then, in catch block rollback method is invoked and all executed methods in stack are discharged. To simulate error occurrences, I generated a random number in runOperation method. If the mode of this number with two is 1, it means an error occurred.

\subsection{Class Diagram}

\begin{figure}[h]
\caption{Class Diagram of Part 3}
\centering
\includegraphics[width=1\textwidth]{figure/part3.png}
\end{figure}

\newpage

\subsection{Tests}

\begin{figure}[h]
\caption{Main Method}
\centering
\includegraphics[width=1\textwidth]{figure/main3.png}
\end{figure}

\begin{figure}[h]
\caption{Output when transaction completed successfully}
\centering
\includegraphics[width=1\textwidth]{figure/output3_1.png}
\end{figure}

\newpage

\begin{figure}[h]
\caption{Output when transaction was not completed successfully}
\centering
\includegraphics[width=1\textwidth]{figure/output3_2.png}
\end{figure}

\section{Part 4} 
\label{sec:background}

\subsection{Design Explanation}

I used Template Method design pattern in this part because both the 1D Discrete Fourier Transform and the 1D Discrete Cosine Transform do the same thing and follow same steps. They read N tab separated numbers from a file provided as a command line argument, transform the numbers into N outputs, write the N outputs to a new file and only in the case of DFT, the time of execution printed on screen if the user wants. \newline

I created an abstract class Transform. It has some methods and lists. numbers list keeps read numbers from file, realPart list keeps real part of transformed numbers, and imagPart list keeps imaginary part of transformed numbers. It also has a startTime data field for DFT. Transform has procedure method. This method can not change by subclasses because it is final. procedure metdod invokes some methods which are readFile, transform, writeFile and printScreen. readFile method reads the input file and adds numbers to numbers list, transform method transforms numbers with proper method, writeFile method writers transformed numbers to output file, and printScreen method returns true if user enters 'y'. Also it has printTime method prints execution time on the screen. transform method and printTime method are abstract so each trasnform types implement own method properly. There are two subclasses of Transform class: DiscreteCosineTransform and DiscreteFourierTransform. They implement transform method and transform numbers with DCT and DFT respectively.\newline
In case of DFT, it gets user input from console as 'y' or 'n' with getUserInput. This method returns the user answer. Then, printScreen method return true if user input is 'y'.\newline
In my design, both method read same input file.
DCT method work with only real numbers so the input file should includes only real numbers.

\newpage

\begin{figure}[h]
\caption{DFT formula}
\centering
\includegraphics[width=0.5\textwidth]{figure/dft.png}
\end{figure}

\begin{figure}[h]
\caption{DCT formula}
\centering
\includegraphics[width=0.5\textwidth]{figure/dct.png}
\end{figure}

\subsection{Class Diagram}

\begin{figure}[h]
\caption{Class Diagram of Part 4}
\centering
\includegraphics[width=0.8\textwidth]{figure/part4.png}
\end{figure}

\newpage

\subsection{Tests}

\begin{figure}[h]
\caption{Main Method}
\centering
\includegraphics[width=1\textwidth]{figure/main4.png}
\end{figure}

\begin{figure}[h]
\caption{Output-1}
\centering
\includegraphics[width=1\textwidth]{figure/output4.png}
\end{figure}

\begin{figure}[h]
\caption{input.txt}
\centering
\includegraphics[width=1\textwidth]{figure/input1.png}
\end{figure}

\begin{figure}[h]
\caption{output\_dft.txt}
\centering
\includegraphics[width=1\textwidth]{figure/dft_out1.png}
\end{figure}

\begin{figure}[h]
\caption{output\_dct.txt}
\centering
\includegraphics[width=1\textwidth]{figure/dct_out1.png}
\end{figure}

\begin{figure}[h]
\caption{Output-2}
\centering
\includegraphics[width=1\textwidth]{figure/output42.png}
\end{figure}

\begin{figure}[h]
\caption{input.txt}
\centering
\includegraphics[width=1\textwidth]{figure/input2.png}
\end{figure}

\begin{figure}[h]
\caption{output\_dft.txt}
\centering
\includegraphics[width=1\textwidth]{figure/dft_out2.png}
\end{figure}

\begin{figure}[h]
\caption{output\_dct.txt}
\centering
\includegraphics[width=1\textwidth]{figure/dct_out2.png}
\end{figure}


\end{document}
